#!/usr/bin/perl

#
# Copyright (C) 2014 Nethesis S.r.l.
# http://www.nethesis.it - support@nethesis.it
# 
# This script is part of NethServer.
# 
# NethServer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or any later version.
# 
# NethServer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with NethServer.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use NethServer::Directory;
use NethServer::Password;
use DBI();
use Data::Dumper;
use Net::LDAP::Util qw(escape_dn_value);

my $ldap = NethServer::Directory->new() || die("Could not connect to LDAP");
my $internalSuffix = NethServer::Directory::getInternalSuffix();

deletePhonebook();
importFromDb();

#
#
#

sub importFromDb
{
    my $response;
    my $dsn = "DBI:mysql:database=phonebook;host=localhost";
    my $db = DBI->connect($dsn, 'root', NethServer::Password->new('/etc/my.pwd')->getAscii()) || die("Could not connect to MySQL");

    my @fields = qw(
     name
     workphone
     fax
     workemail      
     company        
     cellphone      
     workstreet     
     homephone      
     workcity       
     workcountry    
     workprovince   
     title          
     workpostalcode 
    );

    $ldap->merge('ou=Phonebook,' . $internalSuffix, attrs => [
		     objectClass => 'top',
		     objectClass => 'organizationalUnit',
		     ou => 'Phonebook'
		 ]);

    my $selh = $db->prepare("SELECT " . join(', ', @fields) . " FROM phonebook;");
    $selh->execute();
    while(my $row = $selh->fetchrow_hashref()) {

	my $entry = Net::LDAP::Entry->new();
	my $cn = trim(trim($row->{'name'}) . ' ' . trim($row->{'company'}));

	my $dn = sprintf("cn=%s,ou=Phonebook,%s", escape_dn_value($cn), $internalSuffix);

	my $phoneNumber = itu(trim($row->{'workphone'}) || trim($row->{'cellphone'}) || trim($row->{'homephone'}));

	my %H = (
	    'cn' => $cn,
	    'sn' => trim($row->{'name'}) || $cn,
	    'objectClass' => 'inetOrgPerson',

	    # person
	    'telephoneNumber' => $phoneNumber,
	    'description' => trim($row->{'notes'}),
	    'title' => trim($row->{'title'}),

	    # organizationalPerson
	    'street' => trim($row->{'workstreet'}),
	    'postOfficeBox' => trim($row->{'workpob'}),
	    'postalCode' => trim($row->{'workpostalcode'}),
	    'st' => trim($row->{'workprovince'}),
	    'l' => trim($row->{'workcity'}),

	    # inetOrgPerson
	    'o' => trim($row->{'company'}),
	    'displayName' => $cn,
	    'homePhone' => itu(trim($row->{'homephone'})),
	    'mobile' => itu(trim($row->{'cellphone'})),
	);

	foreach (keys %H) {
	    if(! $H{$_}) {
		delete $H{$_};
	    }
	}

	$response = $ldap->merge($dn, attrs => [%H]);

	if($response->is_error()) {
	    print STDERR Dumper($dn, \%H);
	}
    }    
}

sub deletePhonebook
{
    my $response;
    do {
	$response = $ldap->search(
	    base => 'ou=Phonebook,' . $internalSuffix,
	    scope => 'one',
	    filter => 'objectClass=inetOrgPerson'
	    );

	# Drop all existing Phonebook entries:
	foreach ($response->entries()) {
	    $_->delete();
	    $_->update($ldap);
	}
    } while($response->count() > 0);
}


sub trim
{
    my $s = shift;

    $s =~ s/^\s+//;
    $s =~ s/\s+$//;

    return $s;
}


sub itu
{
    my $number = shift;

    $number = trim($number);
    $number =~ s/-+/ /;

    return $number;

    # if(!$number) {
    # 	return '';
    # } elsif($number =~ /^(\+|\()/) {
    # 	return $number;
    # } else {
    # 	return '+39 ' . $number;
    # }
}
